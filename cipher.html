<!DOCTYPE html>
<html>
<head>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Ciphertext</title>
  <style>
    :root {
      --primary: #a8b2c7;
      --secondary: #7a8499;
      --background: #0d0208;
    }
    
    body {
      margin: 0;
      padding: 0;
      background: var(--background);
      color: var(--primary);
      font-family: monospace;
      overflow-x: hidden;
      min-height: 100vh;
    }

    .back-button {
      position: fixed;
      top: 20px;
      left: 20px;
      z-index: 40;
      display: flex;
      align-items: center;
      gap: 10px;
      cursor: pointer;
      opacity: 0.5;
      transition: all 0.3s ease;
    }

    .back-button:hover {
      opacity: 1;
    }

    .back-arrow {
      width: 20px;
      height: 20px;
      fill: var(--primary);
      animation: bounce 2s infinite ease-in-out;
    }

    .warning-text {
      font-size: 0.7rem;
      opacity: 0;
      transform: translateX(-10px);
      transition: all 0.3s ease;
      white-space: nowrap;
    }

    .back-button:hover .warning-text {
      opacity: 1;
      transform: translateX(0);
    }

    @keyframes bounce {
      0%, 20%, 50%, 80%, 100% { transform: translateX(0); }
      40% { transform: translateX(-5px); }
      60% { transform: translateX(-3px); }
    }

    .decoder-method {
      text-align: center;
      font-size: 0.8rem;
      opacity: 0;
      transition: opacity 0.5s ease;
      position: absolute;
      width: 100%;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
    }

    .decoder-method.active {
      opacity: 1;
    }

    #decoder-banner {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(13, 2, 8, 0.95);
      padding: 0.5rem;
      z-index: 20;
      border-top: 1px solid var(--secondary);
    }

    #cipher-container {
      margin-bottom: 2.5rem;
      padding: 1rem;
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
      gap: 10px;
      justify-items: center;
    }

    .cipher-block {
      opacity: 0;
      animation: fadeIn 0.5s forwards;
      padding: 5px;
      text-align: center;
      word-break: break-all;
      font-size: clamp(10px, 2vw, 14px);
      cursor: pointer;
      width: 100%;
      box-sizing: border-box;
      transition: all 0.3s ease;
    }

    .cipher-block:hover,
    .cipher-block.active {
      color: white;
      transform: scale(1.1);
      background: var(--secondary);
      border-radius: 4px;
    }

    #analog-clock {
      position: fixed;
      top: 1px;
      right: 10px;
      width: 50px;
      height: 50px;
      border-radius: 50%;
      background: rgba(13, 2, 8, 0.9);
      border: 1px solid var(--primary);
      opacity: 0.6;
      z-index: 30;
    }

    .clock-hand {
      position: absolute;
      bottom: 50%;
      left: 50%;
      transform-origin: bottom;
      background: var(--primary);
    }

    #hour-hand {
      width: 2px;
      height: 25%;
      transform: translateX(-50%);
    }

    #minute-hand {
      width: 1px;
      height: 35%;
      transform: translateX(-50%);
    }

    #second-hand {
      width: 1px;
      height: 40%;
      background: var(--secondary);
      transform: translateX(-50%);
    }

    .clock-center {
      position: absolute;
      width: 6px;
      height: 6px;
      background: var(--primary);
      border-radius: 50%;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
    }

    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(10px); }
      to { opacity: 1; transform: translateY(0); }
    }

    @media (max-width: 768px) {
      #cipher-container {
        grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
      }
    }
  </style>
</head>
<body>
  <div class="back-button" onclick="history.back()">
    <svg class="back-arrow" viewBox="0 0 24 24">
      <path d="M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.41-1.41L7.83 13H20v-2z"/>
    </svg>
    <span class="warning-text">Go back. Here be dragons.</span>
  </div>

  <div id="decoder-banner">
    <div class="decoder-method" data-method="shift">Shift Cipher: n = (x + 23) mod 26</div>
    <div class="decoder-method" data-method="vigenere">Vigenère: k[i] = (p[i] + key[i]) mod 23</div>
    <div class="decoder-method" data-method="affine">Affine: E(x) = (ax + b) mod 23</div>
    <div class="decoder-method" data-method="substitution">Substitution: σ(x) → (x * 11) mod 23</div>
  </div>

  <div id="cipher-container"></div>
  
  <div id="analog-clock">
    <div id="hour-hand" class="clock-hand"></div>
    <div id="minute-hand" class="clock-hand"></div>
    <div id="second-hand" class="clock-hand"></div>
    <div class="clock-center"></div>
  </div>

  <script>
    class TextProcessor {
      constructor(text) {
        this.text = text;
        this.sentences = text.match(/[^.!?]+[.!?]+/g) || [];
        this.clockBase = 23;
        this.methods = ['shift', 'vigenere', 'affine', 'substitution'];
      }

      modulo(n, m) {
        return ((n % m) + m) % m;
      }

      normalizeChar(char) {
        if (char === ' ') return -1;
        return char.toUpperCase().charCodeAt(0) - 65;
      }

      encryptChar(char, method, position = 0) {
        if (char === ' ') return '99';
        const n = this.normalizeChar(char);
        
        if (n < 0 || n > 25) return '00';
        
        let result;
        switch(method) {
          case 'shift':
            result = this.modulo(n + 23, 26);
            break;
          case 'vigenere':
            result = this.modulo(n + (position * 7), 23);
            break;
          case 'affine':
            result = this.modulo(11 * n + 13, 23);
            break;
          case 'substitution':
            result = this.modulo(n * 11, 23);
            break;
          default:
            result = n;
        }
        
        return result.toString().padStart(2, '0');
      }

      getTrigrams(sentence) {
        const words = sentence.trim().split(/\s+/);
        const trigrams = [];
        for (let i = 0; i < words.length - 2; i++) {
          trigrams.push(words.slice(i, i + 3).join(' '));
        }
        return trigrams;
      }

      generateCipherBlocks() {
        let methodIndex = 0;
        return this.sentences.flatMap(sentence => {
          const trigrams = this.getTrigrams(sentence);
          return trigrams.map(trigram => {
            const method = this.methods[methodIndex];
            methodIndex = (methodIndex + 1) % this.methods.length;
            const cipher = [...trigram].map((char, i) => 
              this.encryptChar(char, method, i)
            ).join('');
            return { cipher, method, original: trigram };
          });
        });
      }
    }

    class AnalogClock {
      constructor() {
        this.hourHand = document.getElementById('hour-hand');
        this.minuteHand = document.getElementById('minute-hand');
        this.secondHand = document.getElementById('second-hand');
      }

      updateClock() {
        const now = new Date();
        const hours = now.getHours() % 12;
        const minutes = now.getMinutes();
        const seconds = now.getSeconds();

        const hourDeg = (hours * 30) + (minutes * 0.5);
        const minuteDeg = minutes * 6;
        const secondDeg = seconds * 6;

        this.hourHand.style.transform = `translateX(-50%) rotate(${hourDeg}deg)`;
        this.minuteHand.style.transform = `translateX(-50%) rotate(${minuteDeg}deg)`;
        this.secondHand.style.transform = `translateX(-50%) rotate(${secondDeg}deg)`;
      }

      start() {
        this.updateClock();
        setInterval(() => this.updateClock(), 1000);
      }
    }

    class DecoderBanner {
      constructor() {
        this.methods = document.querySelectorAll('.decoder-method');
        this.currentMethod = 0;
      }

      showMethod(methodName) {
        this.methods.forEach(method => {
          method.classList.remove('active');
          if (method.dataset.method === methodName) {
            method.classList.add('active');
          }
        });
      }

      start() {
        this.showMethod(this.methods[0].dataset.method);
      }
    }

    async function init() {
      const container = document.getElementById('cipher-container');
      const clock = new AnalogClock();
      const decoder = new DecoderBanner();
      
      const sampleText = `The Library exists ab aeterno. This truth, whose immediate corollary is the future eternity of the world, cannot be placed in doubt by any reasonable mind. The universe, with its elegant endowment of shelves, of enigmatical volumes, of inexhaustible stairways for the traveler and latrines for the seated librarian, can only be the work of a god.`;
      
      const processor = new TextProcessor(sampleText);
      const cipherData = processor.generateCipherBlocks();
      
      let selectedBlock = null;
      
      for (const data of cipherData) {
        const block = document.createElement('div');
        block.className = 'cipher-block';
        block.textContent = data.cipher;
        block.dataset.method = data.method;
        
        block.addEventListener('click', () => {
          if (selectedBlock) {
            selectedBlock.classList.remove('active');
          }
          block.classList.add('active');
          selectedBlock = block;
          decoder.showMethod(data.method);
        });
        
        container.appendChild(block);
        await new Promise(resolve => setTimeout(resolve, 30));
      }
      
      clock.start();
      decoder.start();
    }

    window.addEventListener('load', init);
  </script>
</body>
</html>